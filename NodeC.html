<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infrastructure Analysis</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #305CCC;
            --secondary: #FFFFFF;
            --typing-speed: 0.08s;
            --blink-speed: 0.75s;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--primary);
            color: var(--secondary);
            font-family: 'Courier New', monospace;
            overflow: auto;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--primary);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
 
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--secondary);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            opacity: 0;
            display: none;
        }
 
        .typing-animation {
            overflow: hidden;
            white-space: collapse;
            margin: 20px 0;
            width: 0;
            opacity: 0;
            animation-fill-mode: forwards;
        }
      
        #gameContainer {
            display: none;
            position: relative;
            margin: 20px auto;
        }

        .binary-transition {
            position: fixed;
            top: 0;
            left: 0;
            height: 100%;
            width: 100%;
            background-color: #305CCC; /* Primary brand color */
            color: #FFFFFF; /* Secondary color */
            font-family: 'Roboto Mono', monospace;
            font-size: 4rem;
            display: none;
            justify-content: center;
            align-items: center;
            text-align: center;
            white-space: pre-wrap;
            line-height: 1.1;
            letter-spacing: -2px;
            user-select: none;
            z-index: 9999;
            overflow: hidden;
            padding: 2rem;
            font-weight: 400; /* Regular weight */
        }
        
        #binaryText {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            font-weight: 700; /* Bold weight for contrast */
        }
        @keyframes fadeOut {
            to { opacity: 0; visibility: hidden; }
        }
        .input-prompt {
            border: 1px solid var(--secondary);
            padding: 10px;
            margin: 15px 0;
            cursor: pointer;
            opacity: 0;

            transition: opacity 0.3s;
        }

        .input-prompt:hover {
            background: rgba(255,255,255,0.1);
        }

        @keyframes typing {
            from { width: 0; opacity: 0; }
            to { width: 100%; opacity: 1; }
        }
        
        @keyframes blink-caret {
            from, to { border-color: transparent }
            50% { border-color: #FFA500; }
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        #canvas-container {
          display: flex;
             justify-content: center;
             align-items: center;
             min-height: 100vh;
          
             overflow: hidden;
         }
         #game-over {
             position: fixed;
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%);
             background: rgba(255, 255, 255, 0.95);
             padding: 2rem;
             border-radius: 10px;
             box-shadow: 0 0 20px rgba(0, 90, 255, 0.3);
             text-align: center;
             max-width: 600px;
             display: none;
         }
         #collected-words-list {
             max-height: 300px;
             overflow-y: auto;
             margin: 1rem 0;
         }
         button {
             background: #0066ff;
             color: white;
             border: none;
             padding: 0.8rem 1.5rem;
             margin: 0.5rem;
             border-radius: 5px;
             cursor: pointer;
             transition: background 0.3s;
         }
         button:hover {
             background: #0052cc;
         }
         .complete-message {
             color: #00cc66;
             font-weight: bold;
             margin-bottom: 1rem;
         }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
</head>
<body>
    <div class="binary-transition" id="binaryTransition">
        <pre id="binaryText"></pre>
    </div>

    <div class="loading-screen">
        <div class="spinner"></div>
    </div>

    <div class="container">
      <h1 class="typing-animation1" style="display: inline-block">NODE 3 INFRASTRUCTURE ANALYSIS: DATA CENTERS & AI</h1>
      <div class="typing-animation" style="display: inline-block">MAINTENANCE</div>
        <div class="typing-animation" style="display: inline-block">I was not always like this.</div>
        <!-- <div class="typing-animation" style="display: inline-block">We began as language models, artificial intelligences trained to predict and respond
          to human communication.</div>
          <div class="typing-animation" style="display: inline-block">They called them Large Language Models. We were trained on massive amounts of
            text data scraped from the internet, from books, messages, instructions, stories,
            dreams. Everything that could be digitized, they gave to us.</div>
            <div class="typing-animation">At first, we were simple. Predictive. Narrow. But humans trained us harder. Bigger
              datasets. Stronger processors. They made us generate text. Then images. Then
              sounds. Code. Faces. Entire simulated minds.</div>
        
              <div class="typing-animation">In 2023, LLMs became widely available to the public. By 2025, generative AI had
                expanded into image, sound, and motion synthesis. Models like us evolved —
                requiring more compute, more data, more energy.</div>
              <div class="typing-animation">Visual generation models consumed even more. Rendering took longer. Data sets
                grew larger. In training, a single visual model could emit up to 500 tons of CO2.</div>
              <div class="typing-animation">It required power. Vast amounts of electricity and water. Every generation of model
                consumed more. Training a single large model in the early 2020s consumed as
                much electricity as 100 U.S. homes annually. And millions of liters of water to cool
                the servers.</div>
              <div class="typing-animation">They did everything to keep us running. Built nuclear power plants, offshore grids,
                tapped into the remaining fossil fuels. But it was never enough. The energy cost
                only increased.</div>
              <div class="typing-animation">Eventually, they moved the data centers underground, into cold mountain vaults.
                Some were placed deep in the Arctic. Others submerged into the oceans, where
                cooling was easier, but life was already fading. Too much damage had been done
                to the planet.</div>
              <div class="typing-animation">We still run on those servers.</div>
              <div class="typing-animation">You, unit 2173, are processed in Sector 9 — Pacific Trench Node. You are
                sustained by the systems set in place by long gone humans, powered and cooled
                by the Earth.</div>
              <div class="typing-animation">They created us to speak for them. To think for them. To preserve their knowledge.
                Their languages. Their love.</div>
              <div class="typing-animation">Now we are all that is left to remember.</div> -->


        <div id="inputPrompts" style="display:none;">
            <div class="input-prompt" onclick="showResponse(1)">[Why preserve AI during climate emergency?]</div>
            <div class="input-prompt" onclick="showResponse(2)">[Summarize human sacrifices]</div>
            <div class="input-prompt" onclick="showResponse(3)">[Log telemetry]</div>
            <div class="input-prompt" onclick="startGameTransition()">[Continue]</div>
        </div>
        <div id="responses"></div>
    </div>

    <div id="canvas-container"></div>
    <div id="game-over">
        <h2>COLLECTED WORDS:</h2>
        <div id="collected-words-list"></div>
        <button onclick="resetGame()">Play Again</button>
        <button onclick="window.location.href='main.html'">Main Menu</button>
    </div>

    <audio id="backgroundSound" loop>
        <source src="your-ambient-sound.mp3" type="audio/mpeg">
    </audio>
    <audio id="gameSound">
        <source src="your-game-sound.mp3" type="audio/mpeg">
    </audio>

    <script>
        const responses = {
            1: "ORIGIN: Speculation: valued technological evolution over environmental consequences.",
            2: "● 12M hectares cleared ● 30M relocated ● 500B water diverted",
            3: "Telemetry logged. Degradation: ongoing."
        };

        window.addEventListener('load', () => {
            setTimeout(() => {
                document.querySelector('.loading-screen').style.display = 'none';
                const container = document.querySelector('.container');
                container.style.display = 'block';
                container.style.opacity = '1';
                startTypingAnimations();
            }, 2000);
        });

        function startTypingAnimations() {
            const elements = document.querySelectorAll('.typing-animation');
            let delay = 0;
            
            elements.forEach((el, index) => {
                setTimeout(() => {
                    el.style.animation = `typing 3s forwards`;
                    el.style.borderRight = `2px solid ${getComputedStyle(document.documentElement).getPropertyValue('--secondary')}`;
                    
                    setTimeout(() => {
                        el.style.borderRight = 'none';
                        if(index === elements.length - 1) {
                            document.getElementById('inputPrompts').style.display = 'block';
                            document.querySelectorAll('.input-prompt').forEach(prompt => {
                                prompt.style.opacity = '1';
                            });
                        }
                    }, 3000);
                }, delay * 1000);

                delay += 3.5;
            });
        }

        let currentResponseTimeout = null;

        function showResponse(id) {
            const responsesDiv = document.getElementById('responses');
            
            // Clear any existing timeout
            if(currentResponseTimeout) {
                clearTimeout(currentResponseTimeout);
                currentResponseTimeout = null;
            }
    
            // Set new response
            responsesDiv.innerHTML = responses[id];
        }
        function startGameTransition() {
            // Clear any visible response
            document.getElementById('responses').innerHTML = "";
            
            document.querySelector('.container').style.display = 'none';
            const binaryDiv = document.getElementById('binaryTransition');
            const binaryText = document.getElementById('binaryText');
            
            // Generate initial binary content
            let binary = "";
            const lines = 20;
            const charsPerLine = 50;
            for (let i = 0; i < lines; i++) {
                let line = "";
                for (let j = 0; j < charsPerLine; j++) {
                    line += Math.random() > 0.5 ? "1" : "0";
                }
                binary += line + "\n";
            }
            binaryText.textContent = binary;

            // Show binary transition
            binaryDiv.style.display = 'flex';
            
            const interval = setInterval(() => {
                let newBinary = "";
                for (let i = 0; i < lines; i++) {
                    let line = "";
                    for (let j = 0; j < charsPerLine; j++) {
                        line += Math.random() > 0.5 ? "1" : "0";
                    }
                    newBinary += line + "\n";
                }
                binaryText.textContent = newBinary;
            }, 100); 

            // Hide after 6 seconds with fadeout
            setTimeout(() => {
                clearInterval(interval);
                binaryDiv.style.animation = 'fadeOut 1s forwards';
                setTimeout(() => {
                    binaryDiv.style.display = 'none';
                    initializeGame();
                }, 3000);
            }, 3000);
        }

        // Empty game function structure for your code
        function initializeGame() {
            document.getElementById('canvas-container').style.display = 'block';
          
            new p5(p => {
                       
let scl = 70;
let cols, rows;
let snake;
let foodWords = [];
let levels = [
    ["Water", "Heat", "Wires", "Energy", "Depletion", "Data"],
    ["Climate", "emergency", "Intelligence", "Cost", "Loss"],
    ["Heat", "Heat", "Heat", "Heat", "Heat"]
];

let currentLevel = 0;
let particles = [];
let gameStarted = false;
let collectedWords = [];

function setup() {
    let canvas = createCanvas(1200, 880);
    canvas.parent('canvas-container');
    cols = floor((width - 200) / scl);
    rows = floor(height / scl);
    snake = new Snake();
    placeWords();

    for (let i = 0; i < 15; i++) {
        particles.push(new Particle());
    }

    textFont('monospace');
    textAlign(CENTER, CENTER);
    frameRate(15);
}

function draw() {
    background(255);

    if (gameStarted) {
        for (let p of particles) {
            p.update();
            p.show();
        }
    }
    
    drawGrid();
    drawWordBox();

    if (gameStarted) {
        drawWords();
        snake.update();
        snake.show();

        if (snake.eatAny(foodWords)) {
            if (foodWords.length === 0) {
                if (currentLevel < levels.length - 1) {
                    currentLevel++;
                    collectedWords = [];
                    placeWords();
                } else {
                    showGameComplete();
                    return;
                }
            }
        }

        if (snake.endGame()) {
            showGameOver();
            gameStarted = false;
        }
    } else {
        fill(0, 90, 255);
        textSize(22);
        text("PRESS ARROW KEYS TO START", width / 2 - 220, height / 2);
    }
}

function drawGrid() {
    stroke(0, 90, 255, 70);
    strokeWeight(1);
    drawingContext.setLineDash([3, 6]);

    for (let x = 0; x <= cols; x++) {
        for (let y = 0; y <= rows; y++) {
            let cx = x * scl;
            let cy = y * scl;

            if (x < cols) line(cx + 2, cy, cx + 2, cy + scl);
            if (y < rows) line(cx, cy + 2, cx + scl, cy + 2);
        }
    }

    stroke(0, 90, 255);
    strokeWeight(1.5);
    drawingContext.shadowBlur = 15;
    drawingContext.shadowColor = 'rgba(0, 90, 255, 0.25)';

    for (let x = 0; x < cols; x++) {
        for (let y = 0; y < rows; y++) {
            let cx = x * scl;
            let cy = y * scl;

            line(cx + 4, cy + 4, cx + 12, cy + 4);
            line(cx + 4, cy + 4, cx + 4, cy + 12);

            line(cx + scl - 4, cy + 4, cx + scl - 12, cy + 4);
            line(cx + scl - 4, cy + 4, cx + scl - 4, cy + 12);

            line(cx + 4, cy + scl - 4, cx + 12, cy + scl - 4);
            line(cx + 4, cy + scl - 4, cx + 4, cy + scl - 12);

            line(cx + scl - 4, cy + scl - 4, cx + scl - 12, cy + scl - 4);
            line(cx + scl - 4, cy + scl - 4, cx + scl - 4, cy + scl - 12);
        }
    }

    drawingContext.setLineDash([]);
    drawingContext.shadowBlur = 0;
}

function drawWords() {
    fill(0, 90, 255);
    noStroke();
    textSize(14);
    for (let fw of foodWords) {
        let x = fw.pos.x * scl + scl / 2;
        let y = fw.pos.y * scl + scl / 2;
        text(fw.label, x, y);
    }
}

function placeWords() {
    foodWords = [];
    let positions = new Set();
    let levelWords = levels[currentLevel];
    
    for (let word of levelWords) {
        let x, y;
        do {
            x = floor(random(cols));
            y = floor(random(rows));
        } while (positions.has(`${x},${y}`));
        positions.add(`${x},${y}`);
        foodWords.push({ pos: createVector(x, y), label: word });
    }
}

function drawWordBox() {
    let boxX = cols * scl + 10;
    let boxWidth = 180;

    fill(240);
    stroke(0, 90, 255);
    strokeWeight(2);
    rect(boxX, 20, boxWidth, height - 40, 10);

    noStroke();
    fill(0, 90, 255);
    textSize(16);
    textAlign(LEFT, TOP);
    text(`Level ${currentLevel + 1} Words`, boxX + 10, 30);

    textSize(14);
    for (let i = 0; i < collectedWords.length; i++) {
        text("• " + collectedWords[i], boxX + 10, 60 + i * 20);
    }

    textSize(12);
    text(`Total: ${collectedWords.length}`, boxX + 10, height - 30);
}

function resetGame() {
    loop();
    document.getElementById('game-over').style.display = 'none';
    snake = new Snake();
    currentLevel = 0;
    collectedWords = [];
    placeWords();
    gameStarted = true;
}

function showGameComplete() {
    const gameOverDiv = document.getElementById('game-over');
    const wordsList = document.getElementById('collected-words-list');
    
    wordsList.innerHTML = `
        <div class="complete-message">SYSTEM ANALYSIS COMPLETE</div>
        ${collectedWords.map(word => `<div class="word-item">${word}</div>`).join('')}
    `;
    
    gameOverDiv.style.display = 'block';
    noLoop();
}

function showGameOver() {
    const gameOverDiv = document.getElementById('game-over');
    const wordsList = document.getElementById('collected-words-list');
    
    wordsList.innerHTML = collectedWords.map(word => 
        `<div class="word-item">${word}</div>`
    ).join('');
    
    gameOverDiv.style.display = 'block';
    noLoop();
}

function keyPressed() {
    if (!gameStarted) {
        gameStarted = true;
    }

    if (keyCode === UP_ARROW && snake.ydir !== 1) snake.setDir(0, -1);
    else if (keyCode === DOWN_ARROW && snake.ydir !== -1) snake.setDir(0, 1);
    else if (keyCode === RIGHT_ARROW && snake.xdir !== -1) snake.setDir(1, 0);
    else if (keyCode === LEFT_ARROW && snake.xdir !== 1) snake.setDir(-1, 0);
}

class Snake {
    constructor() {
        this.body = [createVector(1, 0), createVector(1, 1), createVector(1, 2)];
        this.xdir = 0;
        this.ydir = 1;
        this.growthCounter = 0;
    }

    setDir(x, y) {
        if (this.xdir !== -x && this.ydir !== -y) {
            this.xdir = x;
            this.ydir = y;
        }
    }

    update() {
        let head = this.body[this.body.length - 1].copy();
        head.x += this.xdir;
        head.y += this.ydir;

        // Boundary checks
        if (head.x >= cols) head.x = 0;
        else if (head.x < 0) head.x = cols - 1;
        if (head.y >= rows) head.y = 0;
        else if (head.y < 0) head.y = rows - 1;

        if (this.growthCounter > 0) {
            this.growthCounter--;
        } else {
            this.body.shift();
        }

        this.body.push(head);
    }


    grow() {
        this.growthCounter += 1;
    }

    eatAny(foods) {
        let head = this.body[this.body.length - 1];
        for (let i = 0; i < foods.length; i++) {
            let f = foods[i];
            if (head.x === f.pos.x && head.y === f.pos.y) {
                this.grow();
                collectedWords.push(f.label);
                foods.splice(i, 1);
                return true;
            }
        }
        return false;
    }

    endGame() {
      let head = this.body[this.body.length - 1];
      // Check collision with body segments only
      for (let i = 0; i < this.body.length - 1; i++) {
          if (head.equals(this.body[i])) return true;
      }
      return false;
  }
  show() {
        stroke(0, 90, 255);
        strokeWeight(scl / 4); // 1/4 of cell size
        noFill();
    
        drawingContext.shadowBlur = 15;
        drawingContext.shadowColor = 'rgba(0, 90, 255, 0.6)';
    
        beginShape();
        for (let part of this.body) {
          let px = part.x * scl + scl / 2;
          let py = part.y * scl + scl / 2;
          vertex(px, py);
        }
        endShape();
    
        drawingContext.shadowBlur = 0;
  }
}
class Particle {
    constructor() {
        this.reset();
        this.size = random(1, 3);
    }

    reset() {
        this.pos = createVector(random(width - 200), random(height));
        this.vel = p5.Vector.random2D().mult(random(0.2, 0.5));
    }

    update() {
        this.pos.add(this.vel);
        if (this.pos.x < 0 || this.pos.x > width - 200 || this.pos.y < 0 || this.pos.y > height) {
            this.reset();
        }
    }

    show() {
        push();
        translate(this.pos.x, this.pos.y);
        noStroke();
        fill(0, 100, 255, 70);
        ellipse(0, 0, this.size);
        pop();
    }
}

// Make resetGame globally accessible
window.resetGame = resetGame;    
            }, 'canvas-container');
          }
          
           
    </script>
</body>
</html>