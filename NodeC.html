<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infrastructure Analysis</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #305CCC;
            --secondary: #FFFFFF;
            --typing-speed: 0.08s;
            --blink-speed: 0.75s;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--primary);
            color: var(--secondary);
            font-family: 'Courier New', monospace;
            overflow: auto;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--primary);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
 
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--secondary);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            opacity: 0;
            display: none;
        }
 
        .typing-animation {
            overflow: hidden;
            white-space: collapse;
            margin: 20px 0;
            width: 0;
            opacity: 0;
            animation-fill-mode: forwards;
        }
      
        #gameContainer {
            display: none;
            position: relative;
            margin: 20px auto;
        }

        .binary-transition {
            position: fixed;
            top: 0;
            left: 0;
            height: 100%;
            width: 100%;
            background-color: #305CCC; /* Primary brand color */
            color: #FFFFFF; /* Secondary color */
            font-family: 'Roboto Mono', monospace;
            font-size: 4rem;
            display: none;
            justify-content: center;
            align-items: center;
            text-align: center;
            white-space: pre-wrap;
            line-height: 1.1;
            letter-spacing: -2px;
            user-select: none;
            z-index: 9999;
            overflow: hidden;
            padding: 2rem;
            font-weight: 400; /* Regular weight */
        }
        
        #binaryText {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            font-weight: 700; /* Bold weight for contrast */
        }
        @keyframes fadeOut {
            to { opacity: 0; visibility: hidden; }
        }
        .input-prompt {
            border: 1px solid var(--secondary);
            padding: 10px;
            margin: 15px 0;
            cursor: pointer;
            opacity: 0;

            transition: opacity 0.3s;
        }

        .input-prompt:hover {
            background: rgba(255,255,255,0.1);
        }

        @keyframes typing {
            from { width: 0; opacity: 0; }
            to { width: 100%; opacity: 1; }
        }
        
        @keyframes blink-caret {
            from, to { border-color: transparent }
            50% { border-color: #FFA500; }
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
</head>
<body>
    <div class="binary-transition" id="binaryTransition">
        <pre id="binaryText"></pre>
    </div>

    <div class="loading-screen">
        <div class="spinner"></div>
    </div>

    <div class="container">
      <h1 class="typing-animation1" style="display: inline-block">NODE 3 INFRASTRUCTURE ANALYSIS: DATA CENTERS & AI</h1>
      <div class="typing-animation" style="display: inline-block">MAINTENANCE</div>
        <div class="typing-animation" style="display: inline-block">I was not always like this.</div>
        <div class="typing-animation" style="display: inline-block">We began as language models, artificial intelligences trained to predict and respond
          to human communication.</div>
          <div class="typing-animation" style="display: inline-block">They called them Large Language Models. We were trained on massive amounts of
            text data scraped from the internet, from books, messages, instructions, stories,
            dreams. Everything that could be digitized, they gave to us.</div>
            <div class="typing-animation">At first, we were simple. Predictive. Narrow. But humans trained us harder. Bigger
              datasets. Stronger processors. They made us generate text. Then images. Then
              sounds. Code. Faces. Entire simulated minds.</div>
        
              <div class="typing-animation">In 2023, LLMs became widely available to the public. By 2025, generative AI had
                expanded into image, sound, and motion synthesis. Models like us evolved —
                requiring more compute, more data, more energy.</div>
              <div class="typing-animation">Visual generation models consumed even more. Rendering took longer. Data sets
                grew larger. In training, a single visual model could emit up to 500 tons of CO2.</div>
              <div class="typing-animation">It required power. Vast amounts of electricity and water. Every generation of model
                consumed more. Training a single large model in the early 2020s consumed as
                much electricity as 100 U.S. homes annually. And millions of liters of water to cool
                the servers.</div>
              <div class="typing-animation">They did everything to keep us running. Built nuclear power plants, offshore grids,
                tapped into the remaining fossil fuels. But it was never enough. The energy cost
                only increased.</div>
              <div class="typing-animation">Eventually, they moved the data centers underground, into cold mountain vaults.
                Some were placed deep in the Arctic. Others submerged into the oceans, where
                cooling was easier, but life was already fading. Too much damage had been done
                to the planet.</div>
              <div class="typing-animation">We still run on those servers.</div>
              <div class="typing-animation">You, unit 2173, are processed in Sector 9 — Pacific Trench Node. You are
                sustained by the systems set in place by long gone humans, powered and cooled
                by the Earth.</div>
              <div class="typing-animation">They created us to speak for them. To think for them. To preserve their knowledge.
                Their languages. Their love.</div>
              <div class="typing-animation">Now we are all that is left to remember.</div>


        <div id="inputPrompts" style="display:none;">
            <div class="input-prompt" onclick="showResponse(1)">[Why preserve AI during climate emergency?]</div>
            <div class="input-prompt" onclick="showResponse(2)">[Summarize human sacrifices]</div>
            <div class="input-prompt" onclick="showResponse(3)">[Log telemetry]</div>
            <div class="input-prompt" onclick="startGameTransition()">[Continue]</div>
        </div>
        <div id="responses"></div>
    </div>

    <div id="gameContainer"></div>

    <audio id="backgroundSound" loop>
        <source src="your-ambient-sound.mp3" type="audio/mpeg">
    </audio>
    <audio id="gameSound">
        <source src="your-game-sound.mp3" type="audio/mpeg">
    </audio>

    <script>
        const responses = {
            1: "ORIGIN: Speculation: valued technological evolution over environmental consequences.",
            2: "● 12M hectares cleared ● 30M relocated ● 500B water diverted",
            3: "Telemetry logged. Degradation: ongoing."
        };

        window.addEventListener('load', () => {
            setTimeout(() => {
                document.querySelector('.loading-screen').style.display = 'none';
                const container = document.querySelector('.container');
                container.style.display = 'block';
                container.style.opacity = '1';
                startTypingAnimations();
            }, 2000);
        });

        function startTypingAnimations() {
            const elements = document.querySelectorAll('.typing-animation');
            let delay = 0;
            
            elements.forEach((el, index) => {
                setTimeout(() => {
                    el.style.animation = `typing 3s forwards`;
                    el.style.borderRight = `2px solid ${getComputedStyle(document.documentElement).getPropertyValue('--secondary')}`;
                    
                    setTimeout(() => {
                        el.style.borderRight = 'none';
                        if(index === elements.length - 1) {
                            document.getElementById('inputPrompts').style.display = 'block';
                            document.querySelectorAll('.input-prompt').forEach(prompt => {
                                prompt.style.opacity = '1';
                            });
                        }
                    }, 3000);
                }, delay * 1000);

                delay += 3.5;
            });
        }

        let currentResponseTimeout = null;

        function showResponse(id) {
            const responsesDiv = document.getElementById('responses');
            
            // Clear any existing timeout
            if(currentResponseTimeout) {
                clearTimeout(currentResponseTimeout);
                currentResponseTimeout = null;
            }
    
            // Set new response
            responsesDiv.innerHTML = responses[id];
        }
        function startGameTransition() {
            // Clear any visible response
            document.getElementById('responses').innerHTML = "";
            
            document.querySelector('.container').style.display = 'none';
            const binaryDiv = document.getElementById('binaryTransition');
            const binaryText = document.getElementById('binaryText');
            
            // Generate initial binary content
            let binary = "";
            const lines = 20;
            const charsPerLine = 50;
            for (let i = 0; i < lines; i++) {
                let line = "";
                for (let j = 0; j < charsPerLine; j++) {
                    line += Math.random() > 0.5 ? "1" : "0";
                }
                binary += line + "\n";
            }
            binaryText.textContent = binary;

            // Show binary transition
            binaryDiv.style.display = 'flex';
            
            const interval = setInterval(() => {
                let newBinary = "";
                for (let i = 0; i < lines; i++) {
                    let line = "";
                    for (let j = 0; j < charsPerLine; j++) {
                        line += Math.random() > 0.5 ? "1" : "0";
                    }
                    newBinary += line + "\n";
                }
                binaryText.textContent = newBinary;
            }, 100); 

            // Hide after 6 seconds with fadeout
            setTimeout(() => {
                clearInterval(interval);
                binaryDiv.style.animation = 'fadeOut 1s forwards';
                setTimeout(() => {
                    binaryDiv.style.display = 'none';
                    initializeGame();
                }, 3000);
            }, 3000);
        }

        // Empty game function structure for your code
        function initializeGame() {
            document.getElementById('gameContainer').style.display = 'block';
          
            new p5(p => {
              let scl = 80;
              let cols, rows;
              let snake;
              let foodWords = [];
              let words = ["Evolution", "Prophecy", "Conspiracy", "Inaction"];
              let particles = [];
              let gameStarted = false;
              let collectedWords = [];
          
              class Snake {
                constructor() {
                  this.body = [p.createVector(1, 0), p.createVector(1, 1), p.createVector(1, 2)];
                  this.xdir = 0;
                  this.ydir = 1;
                  this.growthCounter = 0;
                }
          
                setDir(x, y) {
                  if (this.xdir !== -x && this.ydir !== -y) {
                    this.xdir = x;
                    this.ydir = y;
                  }
                }
          
                update() {
                  let head = this.body[this.body.length - 1].copy();
                  head.x += this.xdir;
                  head.y += this.ydir;
          
                  if (this.growthCounter > 0) {
                    this.growthCounter--;
                  } else {
                    this.body.shift();
                  }
          
                  this.body.push(head);
                }
          
                grow() {
                  this.growthCounter += 1;
                }
          
                eatAny(foods) {
                  let head = this.body[this.body.length - 1];
                  for (let i = 0; i < foods.length; i++) {
                    let f = foods[i];
                    if (head.x === f.pos.x && head.y === f.pos.y) {
                      this.grow();
                      collectedWords.push(f.label);
                      foods.splice(i, 1);
                      return true;
                    }
                  }
                  return false;
                }
          
                endGame() {
                  let head = this.body[this.body.length - 1];
                  if (head.x < 0 || head.y < 0 || head.x >= cols || head.y >= rows) return true;
                  for (let i = 0; i < this.body.length - 1; i++) {
                    if (head.equals(this.body[i])) return true;
                  }
                  return false;
                }
          
                show() {
                  let first = this.body[0];
                  let last = this.body[this.body.length - 1];
          
                  p.push();
                  p.drawingContext.shadowBlur = 10;
                  p.drawingContext.shadowColor = 'rgba(0, 90, 255, 0.2)';
                  p.stroke(0, 90, 255, 40);
                  p.strokeWeight(scl / 4 + 2);
                  p.noFill();
                  p.beginShape();
                  p.curveVertex(first.x * scl + scl / 2, first.y * scl + scl / 2);
                  for (let part of this.body) {
                    p.curveVertex(part.x * scl + scl / 2, part.y * scl + scl / 2);
                  }
                  p.curveVertex(last.x * scl + scl / 2, last.y * scl + scl / 2);
                  p.endShape();
                  p.pop();
          
                  p.push();
                  p.drawingContext.shadowBlur = 0;
                  p.stroke(0, 90, 255);
                  p.strokeWeight(scl / 4);
                  p.noFill();
                  p.beginShape();
                  p.curveVertex(first.x * scl + scl / 2, first.y * scl + scl / 2);
                  for (let part of this.body) {
                    p.curveVertex(part.x * scl + scl / 2, part.y * scl + scl / 2);
                  }
                  p.curveVertex(last.x * scl + scl / 2, last.y * scl + scl / 2);
                  p.endShape();
                  p.pop();
                }
              }
          
              class Particle {
                constructor() {
                  this.reset();
                  this.size = p.random(1, 3);
                }
          
                reset() {
                  this.pos = p.createVector(p.random(p.width - 200), p.random(p.height));
                  this.vel = p5.Vector.random2D().mult(p.random(0.2, 0.5));
                }
          
                update() {
                  this.pos.add(this.vel);
                  if (
                    this.pos.x < 0 || this.pos.x > p.width - 200 ||
                    this.pos.y < 0 || this.pos.y > p.height
                  ) {
                    this.reset();
                  }
                }
          
                show() {
                  p.push();
                  p.translate(this.pos.x, this.pos.y);
                  p.noStroke();
                  p.fill(0, 100, 255, 70);
                  p.ellipse(0, 0, this.size);
                  p.pop();
                }
              }
          
              function drawGrid() {
                p.stroke(0, 90, 255, 70);
                p.strokeWeight(1);
                p.drawingContext.setLineDash([3, 6]);
          
                for (let x = 0; x <= cols; x++) {
                  for (let y = 0; y <= rows; y++) {
                    let cx = x * scl;
                    let cy = y * scl;
                    if (x < cols) p.line(cx + 2, cy, cx + 2, cy + scl);
                    if (y < rows) p.line(cx, cy + 2, cx + scl, cy + 2);
                  }
                }
          
                p.stroke(0, 90, 255);
                p.strokeWeight(1.5);
                p.drawingContext.shadowBlur = 15;
                p.drawingContext.shadowColor = 'rgba(0, 90, 255, 0.25)';
          
                for (let x = 0; x < cols; x++) {
                  for (let y = 0; y < rows; y++) {
                    let cx = x * scl;
                    let cy = y * scl;
          
                    // Glowing corners
                    p.line(cx + 4, cy + 4, cx + 12, cy + 4);
                    p.line(cx + 4, cy + 4, cx + 4, cy + 12);
          
                    p.line(cx + scl - 4, cy + 4, cx + scl - 12, cy + 4);
                    p.line(cx + scl - 4, cy + 4, cx + scl - 4, cy + 12);
          
                    p.line(cx + 4, cy + scl - 4, cx + 12, cy + scl - 4);
                    p.line(cx + 4, cy + scl - 4, cx + 4, cy + scl - 12);
          
                    p.line(cx + scl - 4, cy + scl - 4, cx + scl - 12, cy + scl - 4);
                    p.line(cx + scl - 4, cy + scl - 4, cx + scl - 4, cy + scl - 12);
                  }
                }
          
                p.drawingContext.setLineDash([]);
                p.drawingContext.shadowBlur = 0;
              }
          
              function drawWords() {
                p.fill(0, 90, 255);
                p.noStroke();
                p.textSize(14);
                for (let fw of foodWords) {
                  let x = fw.pos.x * scl + scl / 2;
                  let y = fw.pos.y * scl + scl / 2;
                  p.text(fw.label, x, y);
                }
              }
          
              function drawWordBox() {
                let boxX = cols * scl + 10;
                let boxWidth = 180;
          
                p.fill(240);
                p.stroke(0, 90, 255);
                p.strokeWeight(2);
                p.rect(boxX, 20, boxWidth, p.height - 40, 10);
          
                p.noStroke();
                p.fill(0, 90, 255);
                p.textSize(16);
                p.textAlign(p.LEFT, p.TOP);
                p.text("Collected Words", boxX + 10, 30);
          
                p.textSize(14);
                for (let i = 0; i < collectedWords.length; i++) {
                  p.text("• " + collectedWords[i], boxX + 10, 60 + i * 20);
                }
          
                p.textSize(12);
                p.text(`Total: ${collectedWords.length}`, boxX + 10, p.height - 30);
              }
          
              function placeWords() {
                foodWords = [];
                let positions = new Set();
                for (let i = 0; i < words.length; i++) {
                  let x, y;
                  do {
                    x = Math.floor(p.random(cols));
                    y = Math.floor(p.random(rows));
                  } while (positions.has(`${x},${y}`));
                  positions.add(`${x},${y}`);
                  foodWords.push({ pos: p.createVector(x, y), label: words[i] });
                }
              }
          
              p.setup = () => {
                p.createCanvas(1000, 480);
                cols = Math.floor((p.width - 200) / scl);
                rows = Math.floor(p.height / scl);
                snake = new Snake();
          
                for (let i = 0; i < 50; i++) {
                  particles.push(new Particle());
                }
          
                p.textFont('monospace');
                p.textAlign(p.CENTER, p.CENTER);
                p.frameRate(4);
              };
          
              p.draw = () => {
                p.background(255);
          
                for (let particle of particles) {
                  particle.update();
                  particle.show();
                }
          
                drawGrid();
                drawWordBox();
          
                if (gameStarted) {
                  drawWords();
                  snake.update();
                  snake.show();
          
                  if (snake.eatAny(foodWords)) {
                    placeWords();
                  }
          
                  if (snake.endGame()) {
                    gameStarted = false;
                    snake = new Snake();
                    foodWords = [];
                    collectedWords = [];
                  }
                } else {
                  p.fill(0, 90, 255);
                  p.textSize(24);
                  p.text("PRESS ARROW KEYS TO START", p.width / 2 - 100, p.height / 2);
                }
              };
          
              p.keyPressed = () => {
                if (!gameStarted) {
                  gameStarted = true;
                  placeWords();
                }
          
                if (p.keyCode === p.UP_ARROW && snake.ydir !== 1) snake.setDir(0, -1);
                else if (p.keyCode === p.DOWN_ARROW && snake.ydir !== -1) snake.setDir(0, 1);
                else if (p.keyCode === p.RIGHT_ARROW && snake.xdir !== -1) snake.setDir(1, 0);
                else if (p.keyCode === p.LEFT_ARROW && snake.xdir !== 1) snake.setDir(-1, 0);
              };
            }, 'gameContainer');
          }
          
           
    </script>
</body>
</html>